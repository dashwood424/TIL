/*
청소하는 영역의 개수를 구함
1. 현재 위치를 청소
2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색
	a. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행
	b. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아감
	c. 네 방향 모두 청소가 이미 되어있거나 벽인 경우, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로
	d. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우 작동을 멈춤

	0: 북, 1: 동, 2: 남, 3: 서
*/

#include <iostream>
using namespace std;

int a[51][51];
int dx[] = { -1, 0, 1, 0 };
int dy[] = { 0, 1, 0, -1 };

int main() {
	int n, m;
	cin >> n >> m;
	int x, y, dir;
	cin >> x >> y >> dir;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> a[i][j];
		}
	}

	while (true) {
		if (a[x][y] == 0) { //현재 칸이 빈칸이면
			a[x][y] = 2; //현재 위치를 청소
		}
		if (a[x][y - 1] != 0 && a[x][y + 1] != 0 && a[x - 1][y] != 0 && a[x + 1][y] != 0) {
			//네 방향 모두 청소가 이미 되어있거나 벽인 경우
			if (a[x - dx[dir]][y - dy[dir]] == 1) { //2-d. 뒤 쪽 방향이 벽이라 후진도 할 수 없는 경우
				break; //작동을 멈춤
			}
			x -= dx[dir];
			y -= dy[dir]; //2-c. 바라보는 방향을 유지한 채로 후진하고 2번으로 
		}
		else {
			//2. 현재 위치에서 왼쪽 방향 탐색. 왼쪽 방향으로 회전
			dir = (dir + 3) % 4;
			if (a[x + dx[dir]][y + dy[dir]] == 0) { //왼쪽방향에 청소하지 않은 공간이 있으면
				x += dx[dir];
				y += dy[dir]; //한 칸을 전진하고 1번으로
			}
		}
	}

	int ans = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (a[i][j] == 2) {
				ans += 1;
			}
		}
	}
	cout << ans << '\n';

	return 0;
}